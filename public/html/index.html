<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Blockly Onshape</title>
  <script src="../client/blockly_compressed.js" charset="utf-8"></script>
  <script src="../client/blocks_compressed.js" charset="utf-8"></script>
  <script src="../client/javascript_compressed.js" charset="utf-8"></script>

  <script src="../client/acorn.js" charset="utf-8"></script>
  <script src="../client/interpreter.js" charset="utf-8"></script>
  <script src="../client/msg/js/en.js" charset="utf-8"></script>

  <style media="screen">
  body {
    padding: 0;
    margin: 0
  }
  #blocklyDiv {
      position: fixed;
      width: 100%;
      height: 100%;
      left: 0;
      top: 0;
    }

  #runButton {
    position: absolute;
    top: 30px;
    right: 30px;
    padding: 10px;
    background-color: rgba(255, 255, 255, 50%);
    color: #999;
    border-radius: 5px;
  }
  </style>

</head>
<body>
  <div id="blocklyDiv"></div>
  <button id="runButton" onclick="runCode(true); return">Send FS Code</button>
</body>
<!-- Define your custom blocks -->
<script src="../client/myBlocksInit.js" charset="utf-8"></script>
<!-- Define your custom blocks generated code -->
<script src="../client/myBlocks.js" charset="utf-8"></script>
<!-- Init API for your JS Interpreter -->
<!-- <script src="myInterpreter.js" charset="utf-8"></script> -->
<!-- Inject your workspace with categories and blocks -->
<script src="../client/workspace.js" charset="utf-8"></script>


<script>

async function runCode(highlighting) {

  

  var fsPrefix = `
    FeatureScript 1389;
    import(path : "onshape/std/geometry.fs", version : "1389.0");
  `
  
  var fsCode = Blockly.JavaScript.workspaceToCode(workspace);


  // TODO: The below modifies the opening lines of the code depending on the presence of precondition, this is a massive hack and should be fixed
    // break the textblock into an array of lines
  var lines = fsCode.split('\n');
  var firstLine = lines[0];
  console.log("First line: " + firstLine)
  if (firstLine.includes("var"))
  {
    // remove one line, starting at the first position
    lines.splice(0,1);
  }else if(!firstLine.includes("precondition")){
    console.log(lines);
    //lines.splice(0, 0, "precondition{} \n { var i = 0;")
  }
  // join the array back into a single string
  var fsCodeNoVar = lines.join('\n');
  

  fsCode =  fsPrefix + fsCodeNoVar;
  //console.log(fsCode);
  //createFeatureStudio()
  copyToClipboard(fsCode);
  copyToFeatureStudio(fsCode);
  // TODO: The following shows execution of code in sync with it running, would be very helpful for troubleshooting.
  // if (highlighting)
  //   Blockly.JavaScript.STATEMENT_PREFIX = 'highlightBlock(%1);\n';
  // else
  //   Blockly.JavaScript.STATEMENT_PREFIX = null;

  // var code = Blockly.JavaScript.workspaceToCode(workspace);

  // var intrepreterAvailable = false;
  // try {
  //   myInterpreter = new Interpreter(code, initApi);
  //   intrepreterAvailable = true;
  // } catch (e) {
  //   console.log("You are using eval() function consider using Interpreter\nhttps://developers.google.com/blockly/guides/app-integration/running-javascript#js_interpreter");
  // } finally {
  //   if (intrepreterAvailable) {
  //     nextStep();
  //   } else {
  //     eval(code);
  //   }
  // }
  // workspace.highlightBlock(null);

}



/*
  Converts the Blockly XML DOM to JSON using the xml2js package
*/

/*
async function convertWorkspaceToJSON() {
  var xml = Blockly.Xml.workspaceToDom(Blockly.mainWorkspace)
  console.log('XML from Blockly:')
  console.log(xml)
  var s = new XMLSerializer();
  var str = s.serializeToString(xml);
  console.log('Serialized XML:')
  console.log(str)

  var parser = new DOMParser();
  var xmlDoc = parser.parseFromString(str,"text/xml");
  console.log('Reparsed xml:')
  console.log(xmlDoc)

  // Format the body of the POST request
  raw = JSON.stringify({
    "contents": `${str}` 
  })
 
  // Define Content-Type for correct body parsing
  header =  {'Content-Type':'application/json'}

  try {
        const response = await fetch(`/api/convertToJSON`, {method: 'POST', body: raw, headers: header});
        const testFour = await response.json();
        console.log('Conversion to json:')
        console.log(testFour)
        return testFour;
    } catch (error) {
        console.error(error);
    };

};
*/
/*
async function convertWorkspaceToXML(workspaceJSON) {

  // Format the body of the POST request
  raw = JSON.stringify({
    "contents": `${workspaceJSON}` 
  })
 
  // Define Content-Type for correct body parsing
  header =  {'Content-Type':'application/json'}

    try {
        const response = await fetch(`/api/convertToXML`, {method: 'POST', body: raw, headers: header});
        const testFive = await response.json();
        console.log('Conversion to xml:')
        console.log(testFive)
        return testFive;
    } catch (error) {
        console.error(error);
    }
}
*/


function copyToClipboard(text) {
    var dummy = document.createElement("textarea");
    // to avoid breaking orgain page when copying more words
    // cant copy when adding below this code
    // dummy.style.display = 'none'
    document.body.appendChild(dummy);
    //Be careful if you use texarea. setAttribute('value', value), which works with "input" does not work with "textarea". â€“ Eduard
    dummy.value = text;
    dummy.select();
    document.execCommand("copy");
    document.body.removeChild(dummy);
}

/*
{
    "formatId": "com.owens-gltf-viewer",
    "name": "blockly-storage",
    "description": "String",
    "jsonTree": {}
}
*/

async function createNewAppElement(fSId, sourceMicroversion, fsCode) {

// Format the body of the POST request
raw = JSON.stringify({
  "formatId": "com.owens-gltf-viewer",
  "name": "blockly-storage",
  "description": "String",
  "jsonTree": {
    "blockly":"empty"
  }
})

// Define Content-Type for correct body parsing
header =  {'Content-Type':'application/json'}

try {
      const response = await fetch(`/api/createAppElement${window.location.search}`, {method: 'POST', body: raw, headers: header});
      const testFour = await response.json();
      return testFour;
  } catch (error) {
      console.error(error);
  }
};

/*
{"btType": "BTJEditChange-2636",
    "path": {"btType": "BTJPath-3073", "startNode": "", "path": [{"btType": "BTJPathKey-3221", "key": "blockly"}]},
    "value": "test"}
*/


async function updateJSONTree(applicationID, changeID, blocklyXML) {

// Format the body of the POST request
raw = JSON.stringify({
  "parentChangeId": `${changeID}`,
  "jsonTreeEdit":{"btType": "BTJEditChange-2636",
    "path": {"btType": "BTJPath-3073", "startNode": "", "path": [{"btType": "BTJPathKey-3221", "key": "blockly"}]},
    "value": `${blocklyXML}`}
  }
)

// Define Content-Type for correct body parsing
header =  {'Content-Type':'application/json'}

try {
      const response = await fetch(`/api/updateAppElement${window.location.search}&storageId=${applicationID}`, {method: 'POST', body: raw, headers: header});
      const testFour = await response.json();
      return testFour;
  } catch (error) {
      console.error(error);
  }
};






/*
  Updates the FeatureStudio contents with the generated Blockly Code

  Input: 

    fsId: Element id of the target FeatureStudio for exporting Blockly code
 
    sourceMicroversion: Microversion of the target Feature Studio document in order to
                        wipe on each code export. 
 
    fsCode: FeatureScript code exported from Blockly
*/

async function updateFeatureStudioContents(fSId, sourceMicroversion, fsCode) {

  // Format the body of the POST request
  raw = JSON.stringify({
    "contents": `${fsCode}`, 
    "serializationVersion": "1.1.20", 
    "sourceMicroversion": `${sourceMicroversion}`
  })
 
  // Define Content-Type for correct body parsing
  header =  {'Content-Type':'application/json'}

  try {
        const response = await fetch(`/api/updateFStudio${window.location.search}&blockly=${fSId}`, {method: 'POST', body: raw, headers: header});
        const testFour = await response.json();
        return testFour;
    } catch (error) {
        console.error(error);
    }
};


/*
   Gets the current FeatureStudio Contents and Specs
   Input:
 
   fsID: Element id of the target FeatureStudio for exporting Blockly code. 
         Stored in blockly query parameter in order to be correctly parsed to Onshape
*/

async function getFeatureStudioContents(fSId) {
  try {
        const response = await fetch(`/api/fsContents${window.location.search}&blockly=${fSId}`, { headers: { 'Accept': 'application/json' } })
        const featurestudioContents = await response.json();
        return featurestudioContents;
    } catch (error) {
        console.error(error);
    }
};


/*
 Gets the FeatureStudio Specs of the FS in development document

 Input:
    
      fsID: This is the element id of the blockly export Feature Studio

*/

async function getFeatureStudioSpecs(fSId) {
    try {
        const response = await fetch(`/api/specsFStudio${window.location.search}&blockly=${fSId}`, { headers: { 'Accept': 'application/json' } })
        const featurestudios = await response.json();
        return featurestudios;
    } catch (error) {
        console.error(error);
    }
};



/*
 Gets the FeatureStudio ID of the FS in development document
*/

async function getFeatureStudio() {
    try {
        const response = await fetch(`/api/getFStudio${window.location.search}`, { headers: { 'Accept': 'application/json' } })
        const featurestudios = await response.json();
        return featurestudios;
    } catch (error) {
        console.error(error);
    }
};


/*
   Gets the Feature List for the Part Studio in which the user is Blockly coding 
*/

async function getFeatureList() {
    try {
        const response = await fetch(`/api/getFeatureList${window.location.search}`, { headers: { 'Accept': 'application/json' } })
        const featurestudios = await response.json();
        return featurestudios;
    } catch (error) {
        console.error(error);
    }
};



/*
   Creates a new blockly export feature studio 
*/

async function createFeatureStudio() {

  raw = JSON.stringify({
    "name": `blockly-export`
  })
 
  header =  {'Content-Type':'application/json'}
  
  try {
        const response = await fetch(`/api/createFStudio${window.location.search}`, {method: 'POST', body: raw, headers: header})
        const featurestudios = await response.json();
        return featurestudios;
    } catch (error) {
        console.error(error);
    }
};




/*
   Adds the Blocky custom feature to the Part Studio Feature List 

   Input:
  
      namespace: e{elementId}::m{microversionID}, element id and microversion id
                This is obtained from the GET FeatureStudiosSpecs endpoint 

      sourceMicroversion: The current source microversion of the document

      fsID: This is the element id of the blockly export feature studio
*/


async function createBlocklyFeature(namespace, sourceMicroversion, fSId) {
  
  raw = JSON.stringify({
    "feature": {
      "type" : 134,
      "typeName": "BTMFeature",
      "message" : {
        "featureType" : "myFeature",
        "name" : "Blockly Created Feature",
        "parameters" : [],
        "namespace" : `${namespace}`
      }
    },
    "serializationVersion": "1.1.20",
    "sourceMicroversion": `${sourceMicroversion}`
  })
 
  header =  {'Content-Type':'application/json'}
  
  try {
        const response = await fetch(`/api/addFeatureToList${window.location.search}&blockly=${fSId}`, {method: 'POST', body: raw, headers: header})
        const featurestudios = await response.json();
        return featurestudios;
    } catch (error) {
        console.error(error);
    }
};


/*
 Gets the FeatureStudio ID of the FS in development document
*/

async function getApplicationID() {
    try {
        const response = await fetch(`/api/getApplicationStorage${window.location.search}`, { headers: { 'Accept': 'application/json' } })
        const featurestudios = await response.json();
        return featurestudios;
    } catch (error) {
        console.error(error);
    }
};


// /appelements/d/79b6a1f263466a880710311c/w/039b2a2fd42a038078b4e3a1/e/1f04edcc213a11e71b04f131/content/json?transactionId=&changeId=

/*
 Gets the FeatureStudio ID of the FS in development document
*/

async function getChangeID(elementId) {
    try {
        const response = await fetch(`/api/getElementChangeId${window.location.search}&storageId=${elementId}`, { headers: { 'Accept': 'application/json' } })
        const jsonTree = await response.json();
        return jsonTree;
    } catch (error) {
        console.error(error);
    }
};


/*
   Boolean function that indicates if there is an export Feature Studio in the document. Returns the index of this 
   in the element list in order for correct data parsing. 
*/

async function hasExportStudio(featureStudios){
  for (var i = 0; i < featureStudios.length; i++) {
    if (featureStudios[i].name == "blockly-export") {
      var hasStudio = true
      var index = i
      return {
        hasStudio,
        index
      }
    }
  }
  var hasStudio = false
  var index = null
  return {
        hasStudio,
        index
      }
}



/*
   Boolean function that indicates if there is a feature for the Blockly code
   in the Feature List of the Part Studio workspace.
*/

async function hasExportFeature(){
  var featureList = await getFeatureList();
  for (var i = 0; i < featureList.features.length; i++) {
    if (featureList.features[i].message.name == "Blockly Created Feature") {
        var hasStudio = true
        return hasStudio
    }
  }
  var hasStudio = false
  return hasStudio
}

async function hasApplicationStorage(featureStudios){
  for (var i = 0; i < featureStudios.length; i++) {
    if (featureStudios[i].name == "blockly-storage") {
      var hasStudio = true
      var index = i
      return {
        hasStudio,
        index
      }
    }
  }
  var hasStudio = false
  var index = null
  return {
        hasStudio,
        index
      }
}


/*
   Copies all of the Blockly code to the Onshape workspace
   
   Input:
 
   fsCode: FeatureScript code exported from Blockly

*/

async function copyToFeatureStudio(fsCode) {

  // Get all FeatureStudios in the document
  var featureStudios = await getFeatureStudio();

  // Check if there are none and if so, create the export FeatureStudio
  if (featureStudios.length == 0) {
    var exportStudio = await createFeatureStudio()
    exportStudioID = exportStudio.id
  } else {

    // If there are FeatureStudios is there already an export FeatureStudio
    results = await hasExportStudio(featureStudios)

    // If there is no export Feature Studio then create one
    if (!(results.hasStudio)) { 
      var exportStudio = await createFeatureStudio()
      exportStudioID = exportStudio.id
    } else {
      var exportStudioID = featureStudios[results.index].id
    }
  }



  // Get the contents of the export Feature Studio
  var currentFsSpecs = await getFeatureStudioSpecs(exportStudioID);

  // Update the Export Feature Studio with Blockly code 
  await updateFeatureStudioContents(exportStudioID, currentFsSpecs.sourceMicroversion, fsCode);

  // Check if there is a Blockly feature in the Part Studio feature list
  var hasFeature = await hasExportFeature()

  // Add the custom feature to the Feature List, get the source microversion in order to correctly place
  if (!(hasFeature)) {
    var updatedFsSpecs = await getFeatureStudioSpecs(exportStudioID);
    await createBlocklyFeature(updatedFsSpecs.featureSpecs[0].message.namespace, updatedFsSpecs.sourceMicroversion, exportStudioID);
  }


  var applications = await getApplicationID();

  // Check if there are none and if so, create the export FeatureStudio
  if (applications.length == 0) {
    var application = await createNewAppElement()
    var applicationID = application.elementId
    var changeID = application.changeId
  } else {

    // If there are FeatureStudios is there already an export FeatureStudio
    results = await hasApplicationStorage(applications)

    // If there is no export Feature Studio then create one
    if (!(results.hasStudio)) { 
      var application = await createNewAppElement()
      var applicationID = application.elementId
      var changeID = application.changeId
    } else {
      var applicationID = applications[results.index].id
      var changeID = (await getChangeID(applicationID)).changeId
    }
  }

  console.log('blocky-storage id:')
  console.log(applicationID)
  console.log('blockly-storage changeId:')
  console.log(changeID)

  var xml = Blockly.Xml.workspaceToDom(Blockly.mainWorkspace)
  console.log('XML from Blockly:')
  console.log(xml)
  var s = new XMLSerializer();
  var str = s.serializeToString(xml);

  await updateJSONTree(applicationID, changeID, str)

}
</script>
</html>
