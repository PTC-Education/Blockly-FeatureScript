<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Blockly Onshape</title>
  <script src="../client/blockly_compressed.js" charset="utf-8"></script>
  <script src="../client/blocks_compressed.js" charset="utf-8"></script>
  <script src="../client/javascript_compressed.js" charset="utf-8"></script>

  <script src="../client/acorn.js" charset="utf-8"></script>
  <script src="../client/interpreter.js" charset="utf-8"></script>
  <script src="../client/msg/js/en.js" charset="utf-8"></script>

  <style media="screen">
  body {
    padding: 0;
    margin: 0
  }
  #blocklyDiv {
      position: fixed;
      width: 100%;
      height: 100%;
      left: 0;
      top: 0;
    }

  #runButton {
    position: absolute;
    top: 30px;
    right: 30px;
    padding: 10px;
    background-color: rgba(255, 255, 255, 50%);
    color: #999;
    border-radius: 5px;
  }
  </style>

</head>
<body>
  <div id="blocklyDiv"></div>
  <button id="runButton" onclick="runCode(true); return">Send FS Code</button>
</body>
<!-- Define your custom blocks -->
<script src="../client/myBlocksInit.js" charset="utf-8"></script>
<!-- Define your custom blocks generated code -->
<script src="../client/myBlocks.js" charset="utf-8"></script>
<!-- Init API for your JS Interpreter -->
<!-- <script src="myInterpreter.js" charset="utf-8"></script> -->
<!-- Inject your workspace with categories and blocks -->
<script src="../client/workspace.js" charset="utf-8"></script>
<script>



function runCode(highlighting) {

  var fsPrefix = `
    FeatureScript 1389;
    import(path : "onshape/std/geometry.fs", version : "1389.0");
  `
  
  var fsCode = Blockly.JavaScript.workspaceToCode(workspace);


  // TODO: The below modifies the opening lines of the code depending on the presence of precondition, this is a massive hack and should be fixed
    // break the textblock into an array of lines
  var lines = fsCode.split('\n');
  var firstLine = lines[0];
  console.log("First line: " + firstLine)
  if (firstLine.includes("var"))
  {
    // remove one line, starting at the first position
    lines.splice(0,1);
  }else if(!firstLine.includes("precondition")){
    console.log(lines);
    //lines.splice(0, 0, "precondition{} \n { var i = 0;")
  }
  // join the array back into a single string
  var fsCodeNoVar = lines.join('\n');
  

  fsCode =  fsPrefix + fsCodeNoVar;
  console.log(fsCode);
  //createFeatureStudio()
  copyToFeatureStudio(fsCode);
  // TODO: The following shows execution of code in sync with it running, would be very helpful for troubleshooting.
  // if (highlighting)
  //   Blockly.JavaScript.STATEMENT_PREFIX = 'highlightBlock(%1);\n';
  // else
  //   Blockly.JavaScript.STATEMENT_PREFIX = null;

  // var code = Blockly.JavaScript.workspaceToCode(workspace);

  // var intrepreterAvailable = false;
  // try {
  //   myInterpreter = new Interpreter(code, initApi);
  //   intrepreterAvailable = true;
  // } catch (e) {
  //   console.log("You are using eval() function consider using Interpreter\nhttps://developers.google.com/blockly/guides/app-integration/running-javascript#js_interpreter");
  // } finally {
  //   if (intrepreterAvailable) {
  //     nextStep();
  //   } else {
  //     eval(code);
  //   }
  // }
  // workspace.highlightBlock(null);

}


function copyToClipboard(text) {
    var dummy = document.createElement("textarea");
    // to avoid breaking orgain page when copying more words
    // cant copy when adding below this code
    // dummy.style.display = 'none'
    document.body.appendChild(dummy);
    //Be careful if you use texarea. setAttribute('value', value), which works with "input" does not work with "textarea". â€“ Eduard
    dummy.value = text;
    dummy.select();
    document.execCommand("copy");
    document.body.removeChild(dummy);
}


/*
  Updates the FeatureStudio contents with the generated Blockly Code

  Input: 

    fsId: Element id of the target FeatureStudio for exporting Blockly code
 
    sourceMicroversion: Microversion of the target Feature Studio document in order to
                        wipe on each code export. 
 
    fsCode: FeatureScript code exported from Blockly
*/

async function updateFeatureStudioContents(fSId, sourceMicroversion, fsCode) {

  // Format the body of the POST request
  raw = JSON.stringify({
    "contents": `${fsCode}`, 
    "serializationVersion": "1.1.20", 
    "sourceMicroversion": `${sourceMicroversion}`
  })
 
  // Define Content-Type for correct body parsing
  header =  {'Content-Type':'application/json'}

  try {
        const response = await fetch(`/api/updateFStudio${window.location.search}&blockly=${fSId}`, {method: 'POST', body: raw, headers: header});
        const testFour = await response.json();
        return testFour;
    } catch (error) {
        console.error(error);
    }
};


/*
   Gets the current FeatureStudio Contents and Specs
   Input:
 
   fsID: Element id of the target FeatureStudio for exporting Blockly code. 
         Stored in blockly query parameter in order to be correctly parsed to Onshape
*/

async function getFeatureStudioContents(fSId) {
  try {
        const response = await fetch(`/api/fsContents${window.location.search}&blockly=${fSId}`, { headers: { 'Accept': 'application/json' } })
        const featurestudioContents = await response.json();
        return featurestudioContents;
    } catch (error) {
        console.error(error);
    }
};






/*
 Gets the FeatureStudio ID of the FS in development document
*/

async function getFeatureStudio() {
    try {
        const response = await fetch(`/api/getFStudio${window.location.search}`, { headers: { 'Accept': 'application/json' } })
        const featurestudios = await response.json();
        return featurestudios;
    } catch (error) {
        console.error(error);
    }
};


async function createFeatureStudio() {
  ///api/featurestudios/d/79b6a1f263466a880710311c/w/039b2a2fd42a038078b4e3a1

  // Format the body of the POST request
  raw = JSON.stringify({
    "name": `blockly-export`
  })
 
  // Define Content-Type for correct body parsing
  header =  {'Content-Type':'application/json'}
  
  try {
        const response = await fetch(`/api/createFStudio${window.location.search}`, {method: 'POST', body: raw, headers: header})
        const featurestudios = await response.json();
        return featurestudios;
    } catch (error) {
        console.error(error);
    }
};


/*
   Combines all helper functions above to export Blockly code to FeatureStudio
   
   Input:
 
   fsCode: FeatureScript code exported from Blockly

*/

async function hasExportStudio(featureStudioID){
  for (var i = 0; i < featureStudioID.length; i++) {
    if (featureStudioID[i].name == 'blockly-export') {
      var hasStudio = true
      var index = i
      return {
        hasStudio,
        index
      }
    } else {
      var hasStudio = false
      var index = null
      return {
        hasStudio,
        index
      }
    }
  }
}


async function copyToFeatureStudio(fsCode) {
  var featureStudioID = await getFeatureStudio();
  console.log(featureStudioID)
  
  var results = await hasExportStudio(featureStudioID)
  console.log(results.hasStudio)
  console.log(results.index)

  if (featureStudioID.length === 0 || (!(results.hasStudio))) { 
    console.log("No export FS!")
    var exportStudio = await createFeatureStudio()
    console.log(exportStudio)
    /*featureStudioID = await getFeatureStudio();
    var results = await hasExportStudio(); 
    console.log('NEW FS!')
    console.log(featureStudioID)
    console.log(results.hasStudio)
    console.log(results.index)
    */
  }
  const featurestudioContents = await getFeatureStudioContents(featureStudioID[results.index].id);
  await updateFeatureStudioContents(featureStudioID[results.index].id, featurestudioContents.sourceMicroversion, fsCode);
}

</script>
</html>
